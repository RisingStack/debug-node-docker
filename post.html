<h1 id="how-to-debug-a-node-app-in-a-docker-container">How to debug a Node app in a Docker container</h1>
<p>According to the Node Foundation’s <a href="https://hackernoon.com/node-js-emerging-as-the-universal-development-framework-for-a-diversity-of-applications-c2e788290f5f">one year old</a> survey more than 50% of Node.js users use Docker for development. While containerization in general is a very powerful tool, and here at RisingStack we always start new projects by spinning up the needed infrastructure in a docker-compose.yaml, it can be tricky to reach the envolped Node process if you don’t know how to do it.</p>
<p>Most of the time you can be well off running your app on your local machine and only use containers to sandbox your databases and queues, but some bugs will only show themselves when the app itself is containerized as well. In these cases it is very helpful to know how to attach a debugger to the service.</p>
<h1 id="node-inspector">Node inspector</h1>
<p>If you mostly use <a href="https://stackoverflow.com/questions/189562/what-is-the-proper-name-for-doing-debugging-by-adding-print-statements">printf, aka caveman debugging</a> it can be very difficult to find the right value at the right time. It gets even worse if your always have to rebuild your container image each time you add <code>console.log</code> to it. It could be a lot easier to have the image built once and jump around within it, examinig your variables while it’s running.</p>
<p>To run your Node app in debug mode simply add <code>inspect</code> after the <code>node</code>, something like that:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">node</span> inspect index.js</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="op">&lt;</span> <span class="ex">Debugger</span> listening on ws://127.0.0.1:9229/5adb6217-0757-4761-95a2-6af0955d7d25</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="op">&lt;</span> <span class="ex">For</span> help, see: https://nodejs.org/en/docs/inspector</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="op">&lt;</span> <span class="ex">Debugger</span> attached.</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ex">Break</span> on start in index.js:1</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="op">&gt;</span> <span class="ex">1</span> (function (exports, require, module, __filename, __dirname) <span class="kw">{</span> <span class="ex">const</span> http = require(<span class="st">&#39;http&#39;</span>)</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="ex">2</span> const PORT = process.env.PORT <span class="kw">||</span> <span class="ex">3000</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="ex">3</span> </a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ex">debug</span><span class="op">&gt;</span> </a></code></pre></div>
<p>When you run your code in inspect mode it always stops at the first line, waiting for you to interact with it. But since For those who were brought up using <code>gdb</code> to debug their code this interface might be compelling. However if you are used to interact with your debugger using a GUI, you might want to open up your chrome and navigate to <code>chrome://inspect</code>.</p>
<p>You should see something like this:</p>
<figure>
<img src="img/chrome-inspector.png" alt="Chrome dev tools" /><figcaption>Chrome dev tools</figcaption>
</figure>
<p>Under remote target, click <code>inspect</code> and you’ll be presented with the Chrome Developer Tools debugger.</p>
<figure>
<img src="img/chrome-debugger.png" alt="Chrome debugger" /><figcaption>Chrome debugger</figcaption>
</figure>
<p>Now you can use the debugger as you please. It’s time to wrap our app in a container.</p>
<h1 id="debugging-in-a-container">Debugging in a container</h1>
<p>First we’ll need to create a Dockerfile,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">FROM</span> node</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">COPY</span> package.json package.json  </a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">RUN</span> npm install</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">COPY</span> . .  </a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">EXPOSE</span> 3000</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="kw">CMD</span> [<span class="st">&quot;node&quot;</span>, <span class="st">&quot;.&quot;</span>]</a></code></pre></div>
<p>and a <code>docker-compose.yaml</code></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">version:</span><span class="at"> </span><span class="st">&#39;3.6&#39;</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="fu">services:</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="fu">app:</span><span class="at"> </span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="fu">build:</span><span class="at"> .</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="fu">ports:</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">      <span class="kw">-</span> <span class="st">&quot;3000:3000&quot;</span> </a></code></pre></div>
<p>Now if you run <code>docker-compose up</code>, you’ll be able to reach your service on <code>http://localhost:3000</code>.</p>
<p>The next step is to expose the debug port to the outside world. First let’s create a <code>debug-compose.yaml</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">version:</span><span class="at"> </span><span class="st">&#39;3.6&#39;</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="fu">services:</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="fu">app:</span><span class="at"> </span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    <span class="fu">build:</span><span class="at"> .</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    <span class="fu">ports:</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">      <span class="kw">-</span> <span class="st">&quot;3000:3000&quot;</span> </a>
<a class="sourceLine" id="cb4-8" data-line-number="8">      <span class="kw">-</span> <span class="st">&quot;9229:9229&quot;</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    <span class="fu">command:</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">      <span class="kw">-</span> node</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">      <span class="kw">-</span> <span class="st">&quot;--inspect-brk=0.0.0.0&quot;</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">      <span class="kw">-</span> <span class="st">&quot;.&quot;</span> </a></code></pre></div>
<p>As you can see, we opened up port 9229, which is the debug port of Node.js apps. We also overrode the command we specified in the <code>Dockerfile</code>. The <code>--inspect-brk=0.0.0.0</code> argument does two different things:</p>
<ol type="1">
<li><code>--inspect</code> tells Node that we want to run our app in debug mode.</li>
<li>by adding <code>-brk</code> we also make sure that the app stops at the first line, so we have enough time to open up the inspector</li>
<li>adding <code>=0.0.0.0</code> opens up the debugger to connections from any IP.</li>
</ol>
<p>By default the inspector is bound to <code>127.0.0.1</code> which makes sense, as normally we don’t want people from all around the world to be able to attach a debugger to our app. However, the container is a different host with a different IP then our host machine, so we won’t be able to reach it. It is fine as long as we do it locally, however, we definitely don’t want this to be run on a live server like this. For this reason <strong>make sure it is a different file from your <code>docker-compose.yaml</code></strong>. In our case, it is called <code>debug-compose.yaml</code>. Of course, we’ll need to maintain two different files, though this problem can be circumvented using a templating engine like handlebars, and we substantially reduced the risk of using the debug setup in production.</p>
<p>With a bit more work, you can expose the debug port from your staging cluster to your IP — but in that case, to <strong>your IP only</strong> — and debug issues there as well.</p>
<p>Also note that the port forwarding rules are enclosed in <code>&quot;</code>-s. If you omit the the rule might not work, making it difficult to figure out why you are not able to attach the debugger to your process.</p>
<p>With all that said, you should be able to inspect your upp in the dev tools.</p>
<figure>
<img src="img/devtools-docker.png" alt="Chrome Dev Tools - Docker" /><figcaption>Chrome Dev Tools - Docker</figcaption>
</figure>
<h1 id="debugging-with-visula-studio-code">Debugging with Visula Studio Code</h1>
<p>It is great to use the inspector for single file issues, though it can have problems descovering all the files in your project. In these cases, it’s better to attach the debugger provided by you IDE. Let’s see how it’s done with Visual Studio Code.</p>
<p>First navigate to the debug tab</p>
<figure>
<img src="img/vscode-palette.png" alt="VSCode Palette" /><figcaption>VSCode Palette</figcaption>
</figure>
<p>then click the gear icon</p>
<figure>
<img src="img/debugger-setup.png" alt="VSCode Debug Setup" /><figcaption>VSCode Debug Setup</figcaption>
</figure>
<p>from the popup list, select docker (make sure, you have the <a href="https://marketplace.visualstudio.com/items?itemName=PeterJausovec.vscode-docker">Docker</a> extension installed)</p>
<figure>
<img src="img/vscode-debuge-popup.png" alt="VSCode Debug Popup" /><figcaption>VSCode Debug Popup</figcaption>
</figure>
<p>it should generate a launch.json in the projects <code>.vscode</code> filder that looks like this:</p>
<figure>
<img src="img/launchjson.png" alt="VSCode launch.json" /><figcaption>VSCode launch.json</figcaption>
</figure>
<p>It’s almost ok, though in our case, the root of our app is the root of the container’s filesystem, so we need to update that as well. The object should look like this, when you’re done:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;Docker: Attach to Node&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="dt">&quot;type&quot;</span><span class="fu">:</span> <span class="st">&quot;node&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="dt">&quot;request&quot;</span><span class="fu">:</span> <span class="st">&quot;attach&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="dt">&quot;port&quot;</span><span class="fu">:</span> <span class="dv">9229</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="dt">&quot;address&quot;</span><span class="fu">:</span> <span class="st">&quot;localhost&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  <span class="dt">&quot;localRoot&quot;</span><span class="fu">:</span> <span class="st">&quot;${workspaceFolder}&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">  <span class="dt">&quot;remoteRoot&quot;</span><span class="fu">:</span> <span class="st">&quot;/&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  <span class="dt">&quot;protocol&quot;</span><span class="fu">:</span> <span class="st">&quot;inspector&quot;</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="fu">}</span></a></code></pre></div>
<p>Now, if you hit F5 on your keyboard you’ll be propmted with the debugger you got used to in VSCode. Hit F5 again, to let the server start listening. If you put a breakpoint somewhere and call the server at <code>htpp://localhost:3000</code> you should see this</p>
<figure>
<img src="img/vscode-debugger.png" alt="VSCode debugger" /><figcaption>VSCode debugger</figcaption>
</figure>
<h1 id="final-thoughts">Final thoughts</h1>
<p>Seeing how container technologies such as Kubernetes, AWS ECS, Docker Swarm and others are being more and more widespread it is clearly visible that containers are here to stay. The fact that you can have the same image run on your local machine while your developing that will eventually land on the cluster is definitely a nice thing as you can bundle the app with the configuration and deploy them together. However, finding bugs that only show themselves when the app is bundled up can be difficult when you rely on printf debugging, so even if you have not used it so far, it is definitely a good idea to become friends with debuggers and learn how to attach them to processes running in your containers.</p>
<p>Happy debugging!</p>
<p>The idea for this post came when we ran into a bug that only arose in the container with <span class="citation" data-cites="fazekasda">[@fazekasda]</span>(https://github.com/fazekasda).</p>
